
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions to simplify rule logic
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isAdmin() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isAdmin == true;
    }
    
    function isCommunityFounder(communityId) {
        return get(/databases/$(database)/documents/communities/$(communityId)).data.founderUid == request.auth.uid;
    }
    
    function isEventSubmitter(eventId) {
        return get(/databases/$(database)/documents/events/$(eventId)).data.submittedByUid == request.auth.uid;
    }
    
    // Incoming data validation functions
    function isValidCommunity(data) {
        return data.name is string && data.name.size() > 0 && data.name.size() <= 100
            && data.slug is string && data.slug.size() > 0 && data.slug.size() <= 50
            && data.type is string
            && data.description is string && data.description.size() <= 160
            && data.fullDescription is string && data.fullDescription.size() <= 2000
            && data.founderUid == request.auth.uid // Enforce ownership
            && data.isVerified == false; // New communities must be unverified
    }
    
     function isValidEvent(data) {
        return data.title is string && data.title.size() > 0 && data.title.size() <= 100
            && data.description is string && data.description.size() > 0
            && data.startDateTime is timestamp
            && data.endDateTime is timestamp && data.endDateTime > data.startDateTime
            && data.submittedByUid == request.auth.uid; // Enforce ownership
    }
    
    function canUpdateCommunity(data) {
       return data.keys().hasOnly(['name', 'type', 'description', 'fullDescription', 'region', 'imageUrl', 'logoUrl', 'tags', 'address', 'phone', 'contactEmail', 'website', 'founded', 'socialMedia', 'updatedAt'])
        && data.name is string && data.name.size() > 0;
    }


    // =================================
    //         Collection Rules
    // =================================

    // Users can read all user profiles for public pages, but can only write to their own.
    match /users/{userId} {
      allow read;
      allow create: if isOwner(userId);
      // Allow updates if the user is the owner, but explicitly prevent them from changing their own admin status.
      allow update: if isOwner(userId) && request.resource.data.isAdmin == resource.data.isAdmin;
    }
    
    // Communities are public to read. Creation requires sign-in. Updates are restricted.
    match /communities/{communityId} {
        allow read;
        allow create: if isSignedIn() && isValidCommunity(request.resource.data);
        allow update: if (isCommunityFounder(communityId) || isAdmin()) && canUpdateCommunity(request.resource.data);
        allow delete: if isAdmin();
    }
    
    // Events are public to read. Creation requires sign-in. Updates are restricted.
    match /events/{eventId} {
        allow read;
        allow create: if isSignedIn();
        allow update: if isEventSubmitter(eventId) || isAdmin();
        allow delete: if isAdmin();
    }
    
    // The "about" page content is public to read, but only admins can write to it.
    match /about/{document} {
      allow read;
      allow write: if isAdmin();
    }
    
    // Default deny all other collections
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
